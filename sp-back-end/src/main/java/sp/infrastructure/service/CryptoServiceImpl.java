package sp.infrastructure.service;

import com.nimbusds.jose.*;
import com.nimbusds.jose.crypto.MACSigner;
import com.nimbusds.jose.crypto.MACVerifier;
import com.nimbusds.jwt.JWTClaimsSet;
import com.nimbusds.jwt.SignedJWT;
import org.springframework.stereotype.Service;
import sp.domain.service.CryptoService;
import sp.domain.shared.DomainError;
import sp.domain.shared.DomainException;
import sp.infrastructure.utility.AESUtil;
import sp.infrastructure.utility.RSAUtil;

import javax.crypto.BadPaddingException;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.spec.InvalidKeySpecException;
import java.text.ParseException;
import java.util.Base64;
import java.util.Date;
import java.util.concurrent.TimeUnit;

@Service
public class CryptoServiceImpl implements CryptoService {

  private byte[] rsaDecrypt(String message, String privateKey)
      throws NoSuchPaddingException, InvalidAlgorithmParameterException, NoSuchAlgorithmException,
          IllegalBlockSizeException, BadPaddingException, InvalidKeyException,
          InvalidKeySpecException {
    return RSAUtil.decrypt(Base64.getDecoder().decode(message), privateKey);
  }

  private byte[] aesDecrypt(String message, byte[] secret)
      throws NoSuchPaddingException, InvalidAlgorithmParameterException, NoSuchAlgorithmException,
          IllegalBlockSizeException, BadPaddingException, InvalidKeyException {
    return AESUtil.decrypt(Base64.getDecoder().decode(message), new SecretKeySpec(secret, "AES"));
  }

  @Override
  public String decryptedPassword(final String encryptedMessage, final String rsaPrivateKey)
      throws DomainException {
    String[] separatedEncryptedMessages = encryptedMessage.split(";");
    String rsaEncryptedKey = separatedEncryptedMessages[0];
    String aesEncryptedPassword = separatedEncryptedMessages[1];
    byte[] password;
    try {
      // Using RSA private key to get the original AES Key
      byte[] aesKey = rsaDecrypt(rsaEncryptedKey, rsaPrivateKey);

      // Uses 16 bit AES Key (generated by the requester) to get the original password
      password = aesDecrypt(aesEncryptedPassword, aesKey);
    } catch (NoSuchPaddingException
        | NoSuchAlgorithmException
        | InvalidAlgorithmParameterException
        | IllegalBlockSizeException
        | BadPaddingException
        | InvalidKeyException
        | InvalidKeySpecException e) {
      throw new DomainException("Failed to decrypt password", e, DomainError.UNEXPECTED_ERROR);
    }
    return new String(password, StandardCharsets.UTF_8);
  }

  @Override
  public String generateJwtTokenForUser(Integer id, String jwtSigningKey, String jwtExpirationTime)
      throws DomainException {
    String subject = id.toString();
    byte[] secret = Base64.getDecoder().decode(jwtSigningKey);
    Date expirationTime = new Date(TimeUnit.SECONDS.toMillis(Long.parseLong(jwtExpirationTime)));

    // Construct claims to be part of the generated JWT
    JWTClaimsSet claims =
        new JWTClaimsSet.Builder()
            .subject(subject)
            .issueTime(new Date())
            .expirationTime(expirationTime)
            .build();

    JWSHeader header = new JWSHeader(JWSAlgorithm.HS512); // Needs 512 bit secret key
    SignedJWT signedJWT = new SignedJWT(header, claims);
    try {
      JWSSigner signer = new MACSigner(secret);
      signedJWT.sign(signer);
    } catch (JOSEException ex) {
      throw new DomainException("Failed to generate token", ex, DomainError.UNEXPECTED_ERROR);
    }
    return signedJWT.serialize();
  }

  @Override
  public Integer getUserIdFrom(String token) throws DomainException {
    try {
      SignedJWT signedJWT = SignedJWT.parse(token);
      return Integer.parseInt(signedJWT.getJWTClaimsSet().getSubject());
    } catch (ParseException ex) {
      throw new DomainException("Token Error !", ex, DomainError.UNEXPECTED_ERROR);
    }
  }

  @Override
  public boolean verifyToken(String token, String secret) throws DomainException {
    try {
      JWSVerifier verifier = new MACVerifier(Base64.getDecoder().decode(secret));
      SignedJWT signedJWT = SignedJWT.parse(token);
      return signedJWT.verify(verifier);
    } catch (JOSEException | ParseException ex) {
      throw new DomainException("Failed to verify token", ex, DomainError.UNEXPECTED_ERROR);
    }
  }
}
